<html lang="en">
<head><title>Graph Theory
</title></head>
<body>
<div style="text-align: center"><h1>Graph Theory</h1></div>
        <h3>What's a Graph?</h3>

            <p>
                Formally, a <i>graph</i> is the following:

            <ul>
                <li> a collection of <i>vertices</i> V, and </li>
                <li>a collection of <i>edges</i> E consisting of pairs of vertices.</li>
            </ul>

            <p> Think of vertices as ``locations''. The set of vertices is the set
                of all the possible locations. In this analogy, edges represent paths
                between pairs of those locations; the set E contains all the paths
                between the locations.

                <h3>Representation</h3>

            <p>
                The graph is normally represented using that analogy. Vertices are points
                or circles; edges are lines between them.
                <br><img src="graph1.gif"><br>

            <p>
                In this example graph, V = {1, 2, 3, 4, 5, 6} and E = {(1,3), (1,6),
                (2,5), (3,4), (3,6)}.

            <p>
                Each <i>vertex</i> is a member of the set V.  A vertex is sometimes called
                a <i>node</i>.

            <p>
                Each <i>edge</i> is a member of the set E. Note that some vertices might
                not be the end point of any edge.  Such vertices are termed `isolated'.

            <p>
                Sometimes, numerical values are associated with edges, specifying lengths
                or costs; such graphs are called <i>edge-weighted</i> graphs (or weighted
                graphs). The value associated with an edge is called the <i>weight</i> of the
                edge.  A similar definition holds for node-weighted graphs,

                <h3>Examples of Graphs</h3>

                    <h5>Telecowmunication (USACO Championship 1996)</h5>

            <p>
                Given a set of computers and a set of wires running between pairs of
                computers, what is the minimum number of machines whose crash causes
                two given machines to be unable to communicate? (The two given machines
                will not crash.)

            <p>
                Graph: The vertices of the graph are the computers.  The edges are the
                wires between the computers.

            <h5>Sample Problem: Riding The Fences</h5>

            <p>
                Farmer John owns a large number of fences, which he must periodically
                check for integrity. He keeps track of his fences by maintaining a list
                of points at which fences intersect. He records the name of the point
                and the one or two fence names that touch that point.  Every fence has
                two end points, each at some intersection point, although the intersection
                point may be the end point of only one fence.

            <p>
                Given a fence layout, calculate if there is a way for Farmer John to
                ride his horse to all of his fences without riding along a fence more
                than once. Farmer John can start and finish anywhere, but cannot cut
                across his fields (i.e., the only way he can travel between intersection
                points is along a fence). If there is a way, find one way.

            <p>
                Graph: Farmer John starts at intersection points and travels between
                the points along fences.  Thus, the vertices of the underlying graph
                are the intersection points, and the fences represent edges.

            <h5>Knight moves</h5>

            <p>
                Given: Two squares on an 8x8 chessboard.  Determine the shortest sequence
                of knight moves from one square to the other.

            <p>
                Graph: The graph here is harder to see.  Each location on the chessboard
                represents a vertex.  There is an edge between two positions if it is
                a legal knight move.

            <h5>Overfencing [Kolstad & Schrijvers, Spring 1999 USACO Open]</h5>

            <p>
                Farmer John created a huge maze of fences in a field.  He omitted two
                fence segments on the edges, thus creating two ``exits'' for the maze.
                The maze is a `perfect' maze; you can find a way out of the maze from
                any point inside it.

            <p>
                Given the layout of the maze, calculate the number of steps required to
                exit the maze from the `worst' point in the maze (the point that is
                `farther' from either exit when walking optimally to the closest exit).

            <p>
                Here's what one particular W=5, H=3 maze looks like:
                <br>
                <pre> <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-+-+-+-+-+<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-+&nbsp;+-+&nbsp;+&nbsp;+<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;|<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;+-+-+&nbsp;+&nbsp;+<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-+&nbsp;+-+-+-+<br>
</pre>>

            <p>
                Graph: The vertices of the graph are positions in the grid.  There
                is an edge between two vertices if they represent adjacent positions
                that are not separated by a wall.

                <h3>Terminology</h3>

                    Let's look again at the first example graph:
                    <br><img src="graph1.gif"><br>

            <p>
                An edge is a <i>self-loop</i> if it is of the form (u,u).  The
                sample graph contains no self-loops.

            <p>
                A graph is <i>simple</i> if it neither contains self-loops nor contains
                an edge that is repeated in E.  A graph is called a <i>multigraph</i>
                if it contains a given edge more than once or contain self-loops. For
                our discussions, graphs are assumed to be simple.  The example graph is
                a simple graph.

            <p>
                An edge (u,v) is <i>incident</i> to both vertex u and vertex v. For
                example, the edge (1,3) is incident to both vertex 1 and vertex 3.

            <p>
                The <i>degree</i> of a vertex is the number of edges which are incident
                to it. For example, vertex 3 has degree 3, while vertex 4 has degree 1.

            <p>
                Vertex u is <i>adjacent</i> to vertex v if there is some edge to which
                both are incident (that is, there is an edge between them). For example,
                vertex 2 is adjacent to vertex 5.

            <p>
                A graph is said to be <i>sparse</i> if the total number of edges is small
                compared to the total number possible ((<i>N  x  (N-1))/2</i>) and <i>dense</i>
                otherwise. For a given graph, whether it is dense or sparse is not
                well-defined.

                <h3>Directed Graph</h3>

            <p>
                Graphs described thus far are called <i>undirected</i>, as the edges go
                `both ways'. So far, the graphs have connoted that if one can travel
                from vertex 1 to vertex 3, one can also travel from vertex 3 to vertex 1. In
                other words, (1,3) being in the edge set implies (3,1) is in the edge
                set.

            <p>
                Sometimes, however, a graph is <i>directed</i>, in which case the edges
                have a direction.  In this case, the edges are called <i>arcs</i>.

            <p>
                Directed graphs are drawn with arrows to show direction.
                <br><img src="graph2.gif"><br>

            <p>
                The <i>out-degree</i> of a vertex is the number of arcs which <i>begin</i>
                at that vertex.  The <i>in-degree</i> of a vertex is the number of arcs
                which <i>end</i> at that vertex. For example, vertex 6 has in-degree 2
                and out-degree 1.

            <p>
                A graph is assumed to be undirected unless specifically called a directed
                graph.

                <h3>Paths</h3>

            <p> A <i>path</i> from vertex <i>u</i> to vertex <i>x</i> is a
                sequence of vertices (<i>v <sub> 0</sub></i>, <i>v <sub> 1</sub></i>,
                ..., <i>v <sub> k</sub></i>) such that <i>v <sub> 0</sub></i> =
                <i>u</i> and <i>v <sub>k</sub></i> = <i>x</i> and (<i>v <sub>
                    0</sub></i>, <i>v <sub> 1</sub></i>) is an edge in the graph, as
                is (<i>v <sub> 1</sub></i>, <i>v <sub> 2</sub></i>), (<i>v <sub>
                    2</sub></i>, <i>v <sub> 3</sub></i>), etc. The length of such a
                path is <i>k</i>.

            <p> For example, in the undirected graph above, (4, 3, 1, 6) is a
                path.

                <br><img src="graph3.gif"><br>

            <p> This path is said to <i>contain</i> the vertices <i>v <sub>
                0</sub></i>, <i>v <sub> 1</sub></i>, etc., as well as the edges
                (<i>v <sub> 0</sub></i>, <i>v <sub> 1</sub></i>), (<i>v <sub>
                    1</sub></i>, <i>v <sub> 2</sub></i>), etc.

            <p> Vertex <i>x</i> is said to be <i>reachable</i> from vertex
                <i>u</i> if a path exists from <i>u</i> to <i>x</i>.

            <p>
                A path is <i>simple</i> if it contains no vertex more than once.

            <p> A path is a <i>cycle</i> if it is a path from some vertex to
                that same vertex.  A cycle is <i>simple</i> if it contains no vertex
                more than once, except the start (and end) vertex, which only
                appears as the first and last vertex in the path.

            <p> These definitions extend similarly to directed graphs (e.g.,
                (<i>v <sub> 0</sub></i>, <i>v <sub> 1</sub></i>), (<i>v <sub>
                    1</sub></i>, <i>v <sub> 2</sub></i>), etc. must be arcs).

                <h3>Graph Representation</h3>

            <p> The choice of representation of a graph is important, as
                different representations have very different time and space costs.

            <p> The vertices are generally tracked by numbering them, so that
                one can index them just by their number. Thus, the representations
                focus on how to store the <i>edges</i>.

            <h5>Edge List</h5>

            <p>
                The most obvious way to keep track of the edges is to keep a list of
                the pairs of vertices representing the edges in the graph.

            <p>
                This representation is easy to code, fairly easy to debug, and fairly
                space efficient.  However, determining the edges incident to a given
                vertex is expensive, as is determining if two vertices are adjacent.
                Adding an edge is quick, but deleting one is difficult if its location
                in the list is not known.

            <p>
                For weighted graphs, this representation also keeps one more number for
                each edge, the edge weight. Extending this data structure to handle
                directed graphs is straightforward.  Representing multigraphs is also
                trivial.

            <h5>Example</h5>

            The sample undirected graph might be represented as the following
            list of edges:

            <div style="text-align: center">
                <table>
                    <tr> <td> &nbsp; </td> <td><i>V<sub>1</sub></i></td> <td><i>V<sub>2</sub></i></td></tr>
                    <tr><td><i>e<sub>1</sub></i></td> <td>4</td> <td>3</td>
                    <tr><td><i>e<sub>2</sub></i></td> <td>1</td> <td>3</td>
                    <tr><td><i>e<sub>3</sub></i></td> <td>2</td> <td>5</td>
                    <tr><td><i>e<sub>4</sub></i></td> <td>6</td> <td>1</td>
                    <tr><td><i>e<sub>5</sub></i></td> <td>3</td> <td>6</td>
                </table>
            </div>

            <h5>Adjacency Matrix</h5>

            <p>
                A second way to represent a graph utilizes an <i>adjacency matrix</i>.
                This is a N by N array (N is the number of vertices).  The i,j entry
                contains a 1 if the edge (i,j) is in the graph; otherwise it contains
                a 0.  For an undirected graph, this matrix is symmetric.

            <p>
                This representation is easy to code. It's much less space efficient,
                especially for large, sparse graphs. Debugging is harder, as the matrix is
                large. Finding all the edges incident to a given vertex is fairly
                expensive (linear in the number of vertices), but checking if two vertices
                are adjacent is very quick. Adding and removing edges are also very
                inexpensive operations.

            <p>
                For weighted graphs, the value of the (i,j) entry is used to store the
                weight of the edge. For an unweighted multigraph, the (i,j) entry can
                maintain the number of edges between the vertices.  For a weighted
                multigraph, it's harder to extend this.

            <h5> Example</h5>

            <p> The sample undirected graph would be represented by the following
                adjacency matrix:

            <div style="text-align: center">
                <table>
                    <tr><td>&nbsp;</td> <td><i>V<sub>1</sub></i></td> <td><i>V<sub>2</sub></i></td> <td><i>V<sub>3</sub></i></td> <td><i>V<sub>4</sub></i></td> <td><i>V<sub>5</sub></i></td> <td><i>V<sub>6</sub></i></td><tr>
                    <tr><td align="center"><i>V<sub>1</sub></i></td> <td align="center">0</td> <td align="center">0</td> <td align="center">1</td> <td align="center">0</td> <td align="center">0</td> <td align="center">1</td><tr>
                    <tr><td align="center"><i>V<sub>2</sub></i></td> <td align="center">0</td> <td align="center">0</td> <td align="center">0</td> <td align="center">0</td> <td align="center">1</td> <td align="center">0</td><tr>
                    <tr><td align="center"><i>V<sub>3</sub></i></td> <td align="center">1</td> <td align="center">0</td> <td align="center">0</td> <td align="center">1</td> <td align="center">0</td> <td align="center">1</td><tr>
                    <tr><td align="center"><i>V<sub>4</sub></i></td> <td align="center">0</td> <td align="center">0</td> <td align="center">1</td> <td align="center">0</td> <td align="center">0</td> <td align="center">0</td><tr>
                    <tr><td align="center"><i>V<sub>5</sub></i></td> <td align="center">0</td> <td align="center">1</td> <td align="center">0</td> <td align="center">0</td> <td align="center">0</td> <td align="center">0</td><tr>
                    <tr><td align="center"><i>V<sub>6</sub></i></td> <td align="center">1</td> <td align="center">0</td> <td align="center">1</td> <td align="center">0</td> <td align="center">0</td> <td align="center">0</td><tr>
                </table>
            </div>

            <p>
                It is sometimes helpful to use the fact that the (i,j) entry of the
                adjacency matrix raised to the k-th power gives the number of paths from
                vertex i to vertex j consisting of exactly k edges.

            <h5>Adjacency List</h5>

            <p>
                The third representation of graph is to keep track of all the edges
                incident to a given vertex.  This can be done by using an array of
                length N, where N is the number of vertices.  The i<sup>th</sup> entry
                in this array is a list of the edges incident to i'th vertex (edges are
                represented by the index of the other vertex incident to that edge).

            <p>
                This representation is much more difficult to code, especially if the
                number of edges incident to each vertex is not bounded, so the lists
                must be linked lists (or dynamically allocated).  Debugging this is
                difficult, as following linked lists is more difficult.  However, this
                representation uses about as much memory as the edge list.  Finding the
                vertices adjacent to each node is very cheap in this structure, but
                checking if two vertices are adjacent requires checking all the edges
                adjacent to one of the vertices. Adding an edge is easy, but deleting
                an edge is difficult, if the locations of the edge in the appropriate
                lists are not known.

            <p>
                Extend this representation to handle weighted graphs by maintaining both
                the weight and the other incident vertex for each edge instead of just
                the other incident vertex. Multigraphs are already representable.
                Directed graphs are also easily handled by this representation, in one
                of several ways: store only the edges in one direction, keep a seperate
                list of incoming and outgoing arcs, or denote the direction of each arc
                in the list.

            <h5>Example</h5>

            The adjacency list representation of the example undirected graph is as
            follows:

            <div style="text-align: center">
                <table>
                    <tr><td align="center">&nbsp;</td>  <td align="center">Adjacent</td></tr>
                    <tr><td align="center">Vertex</td>  <td align="center">Vertices</td></tr>
                    <tr><td align="center">1</td>  <td align="center">3, 6</td></tr>
                    <tr><td align="center">2</td>  <td align="center">5</td></tr>
                    <tr><td align="center">3</td>  <td align="center">6, 4, 1</td></tr>
                    <tr><td align="center">4</td>  <td align="center">3</td></tr>
                    <tr><td align="center">5</td>  <td align="center">2</td></tr>
                    <tr><td align="center">6</td>  <td align="center">3, 1</td></tr>
                </table>
            </div>

            <h5>Implicit Representation</h5>

            <p>
                For some graphs, the graph itself does not have to be stored at all.
                For example, for the Knight moves and Overfencing problems, it is easy
                to calculate the neighbors of a vertex, check adjacency, and determine
                all the edges without actually storing that information, thus, there is
                no reason to actually store that information; the graph is implicit in
                the data itself.

            <p>
                If it is possible to store the graph in this format, it is generally
                the correct thing to do, as it saves a lot on storage and reduces the
                complexity of your code, making it easy to both write and debug.

            <p>
                If N is the number of vertices, M the number of edges, and <i>d <sub> max</sub></i>
                the maximum degree of a node, the following table summarizes the
                differences between the representations:

            <div style="text-align: center">
                <table>
                    <tr><td>Efficiency</td> <td align="center">Edge List</td> <td align="center">Adj Matrix</td> <td align="center">Adj List</td></tr>
                    <tr><td>Space</td> <td align="center">2xM</td> <td align="center">N<sup>2</sup></td> <td align="center">2xM</td></tr>
                    <tr><td>Adjacency Check</td> <td align="center">M</td> <td align="center">1</td> <td align="center"><i>d <sub> max</sub></i></td></tr>
                    <tr><td>List of Adj Vertices</td> <td align="center">M</td> <td align="center">N</td> <td align="center"><i>d <sub> max</sub></i></td></tr>
                    <tr><td>Add Edge</td> <td align="center">1</td> <td align="center">1</td> <td align="center">1</td></tr>
                    <tr><td>Delete Edge</td> <td align="center">M</td> <td align="center">2</td> <td align="center">2x<i>d <sub> max</sub></i></td></tr>
                </table>
            </div>

            <h3>Connectedness</h3>

                <p>
                    An undirected graph is said to be <i>connected</i> if there is a
                    path from every vertex to every other vertex. The example graph
                    is <i>not</i> connected, as there is no path from vertex 2 to
                    vertex 4.

                    <br><img src="graph1.gif"><br>

                    However, if you add an edge between vertex 5 and vertex 6, then
                    the graph becomes connected.

                    <br><img src="graph1a.gif"><br>

                <p>
                    A <i>component</i> of a graph is a maximal subset of the vertices such
                    that every vertex is reachable from each other vertex in the component.
                    The original example graph has two components: {1, 3, 4, 6} and {2, 5}.
                    Note that {1, 3, 4} is not a component, as it is not maximal.

                <p>
                    A directed graph is said to be <i>strongly connected</i> if there is a
                    path from every vertex to every other vertex.

                <p>
                    A <i>strongly connected component</i> of a directed graph is a vertex
                    u and the collection of all vertices v such that there is a path from
                    u to v and a path from v to u.

                    <h3>Subgraphs</h3>

                <p>
                    Graph G' = (V', E') is a subgraph of G = (V, E) if V' is a subset
                    of V and E' is a subset of E.

                <p>
                    The subgraph of G <i>induced</i> by V' is the graph (V', E'), where E'
                    consists of all the edges of E that are between members of V'.

                <p>
                    For example, for V' = {1, 3, 4, 2}, the subgraph induced is:

                    <br><img src="graph4.gif"><br>

                    <h3>Special Graphs</h3>

                <p>
                    An undirected graph is said to be a <i>tree</i> if it contains no cycles
                    and is connected.

                    <br><img src="graph5.gif"><br>

                <p>
                    Many trees are what is called <i>rooted</i>, where there is a notion of
                    the "top" node, which is called the <i>root</i>.  Thus, each node has
                    one <i>parent</i>, which is the adjacent node which is closer to the
                    root, and may have any number of <i>children</i>, which are the rest of
                    the nodes adjacent to it.  The tree above was drawn as a rooted tree.

                <p>
                    An undirected graph which contains no cycles is called a <i>forest</i>.
                    <br><img src="graph6.gif"><br>

                <p>
                    A directed acyclic graph is often referred to as a <i>dag</i>.

                <p>
                    A graph is said to be <i>complete</i> if there is an edge between every
                    pair of vertices.
                    <br><img src="graph7.gif"><br>

                <p>
                    A graph is said to be <i>bipartite</i> if the vertices can be split into
                    two sets <i>V <sub> 1</sub></i> and <i>V <sub> 2</sub></i> such there are no edges between two vertices of
                    <i>V <sub> 1</sub></i> or two vertices of <i>V <sub> 2</sub></i>.

                    <br><img src="graph8.gif"><br>

<p><a href="../../../index.html">Training Gateway</a></p>
</body>
</html>
